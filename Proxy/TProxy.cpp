// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "TProxyService.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/server/TThreadedServer.h>
#include <thrift/transport/TBufferTransports.h>

#include <thrift/concurrency/ThreadManager.h>
#include <thrift/concurrency/PosixThreadFactory.h>
#include <thrift/server/TThreadPoolServer.h>
#include <thrift/transport/TTransportUtils.h>


#include <vector>

#include "../Caravel/RedisHelper.h"
#include "../Caravel/PRF.h"
#include "../fastore/OREHelper.h"

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;
using namespace ::apache::thrift::concurrency;

using namespace caravel;
using boost::shared_ptr;
using namespace std;
using namespace  ::proxyserver;

#define SHA256_DIGEST_LENGTH 32
#define INDEX_STOP_FLAG 1234567890
//#define DEBUG_TPROXY_FLAG

class TProxyServiceHandler : virtual public TProxyServiceIf {
public:
	TProxyServiceHandler() {
		// Your initialization goes here

		cout << "TProxyServiceHandler Begin Init" << endl;
		redisHelper.OpenPool();
		cout << "TProxyServiceHandler End Init" << endl;

	}

	uint32_t uiBlockSizeInBits;

	RedisHelper redisHelper;

	/**
	 * ProxyGet API
	 * @return Encrypted value in binary
	 *
	 * @param Trapdoor, i.e., pseudo-random label
	 */
	void ProxyGet(std::string& _return, const std::string& Trapdoor) {

#ifdef DEBUG_TPROXY_FLAG
		printf("ProxyGet\n");
#endif

		uint32_t uiSize = redisHelper.PoolGet(Trapdoor, _return);

		if (0 == uiSize)
		{
			_return = "";
		}

	}

	/**
	 * ProxyPut API: put and index the value
	 *
	 * @param Trapdoor
	 * @param Encrypted value
	 * @param IndexTrapdoor
	 * @param IndexVal, i.e., encrypted pseudo-random label
	 */
	void ProxyPut(const std::string& Trapdoor, const std::string& Val, const std::string& IndexTrapdoor, const std::string& IndexVal) {

#ifdef DEBUG_TPROXY_FLAG
		printf("ProxyPut\n");
#endif

		redisHelper.PoolPut(Trapdoor, Val);

		if (0 != IndexTrapdoor.length())
		{
			//index the data value
			redisHelper.PoolPut(IndexTrapdoor, IndexVal);

		}

	}

	/**
	 * ProxyGetColumn
	 * @return a list of encrypted values for a given column attribute
	 *
	 * @param IndexTrapdoor
	 * @param IndexMask
	 * @param GetNum
	 */
	void ProxyGetColumn(std::vector<std::string> & _return, const std::string& IndexTrapdoor, const std::string& IndexMask, const int32_t GetNum) {

#ifdef DEBUG_TPROXY_FLAG
		printf("ProxyGetColumn\n");
#endif

		//foreach counter = 0 to GetNum
		const uint32_t kIndexValSize = SHA256_DIGEST_LENGTH + sizeof(uint32_t);
		char szTmp[kIndexValSize];
		string strIndexTrapdoor;
		string strIndexMask;
		string strTrapdoor;
		string strVal;
		for (uint32_t uiCounter = 0; uiCounter < GetNum; uiCounter++)
		{
			//Generate the Index Trapdoor per data value with counter
			PRF::Sha256((char*)&uiCounter, sizeof(uiCounter), (char*)IndexTrapdoor.c_str(), IndexTrapdoor.length(), szTmp, SHA256_DIGEST_LENGTH);
			strIndexTrapdoor.assign(szTmp, SHA256_DIGEST_LENGTH);

			//Generate the Index Mask per data value with counter
			PRF::Sha256((char*)&uiCounter, sizeof(uiCounter), (char*)IndexMask.c_str(), IndexMask.length(), szTmp, SHA256_DIGEST_LENGTH);
			strIndexMask.assign(szTmp, SHA256_DIGEST_LENGTH);

			string strIndexVal;
			redisHelper.PoolGet(strIndexTrapdoor, strIndexVal);
			if (strIndexVal.length() == 0)
			{
				continue;
			}

			if (INDEX_STOP_FLAG == *(uint32_t*)(strIndexVal.c_str()) ^ *(uint32_t*)(strIndexMask.c_str()))
			{
				memcpy(szTmp, strIndexMask.c_str(), SHA256_DIGEST_LENGTH);
				//set the padding to 0
				*(uint32_t*)(szTmp + SHA256_DIGEST_LENGTH) = 0;

				//strIndexVal = [{Mask}{0000}] ^ [{FLAG}{Trapdoor}]
				//foreach byte do XOR (decrypt the index entry) and get Trapdoor for the data value
				char *pTrapdoor = szTmp + sizeof(uint32_t);
				const char *pIndexVal = strIndexVal.c_str() + sizeof(uint32_t);
				for (uint32_t uiCur = 0; uiCur < SHA256_DIGEST_LENGTH; uiCur++)
				{
					pTrapdoor[uiCur] ^= pIndexVal[uiCur];
				}

				strTrapdoor.assign(pTrapdoor, SHA256_DIGEST_LENGTH);

				//Get the encrypted value by Trapdoor
				redisHelper.PoolGet(strTrapdoor, strVal);

				if (strVal.length() == 0)
				{
					continue;
				}

				//Add to return vector
				_return.push_back(strVal);
			}
			else
			{
				return;
			}

		}

		//Close the Redis Connection

	}



	/**
	* EqualSearch1
	* @return a binary list of Key, with linear comparation
	*
	* @param IndexTrapdoor
	* @param IndexMask
	*/
	void EqualSearch1(std::vector<std::string> & _return, const std::string& IndexTrapdoor, const std::string& IndexMask) {
		// Your implementation goes here

		uint32_t uiCounter = 0;

		const uint32_t kIndexValSize = SHA256_DIGEST_LENGTH + SHA256_DIGEST_LENGTH;
		char szIndexTd[kIndexValSize];

		string strIndexTrapdoor;
		string strIndexVal;
		string strRet;
		string strIndexEqual;

		while (true)
		{
			PRF::Sha256((char*)&uiCounter, sizeof(uiCounter), (char*)IndexTrapdoor.c_str(), IndexTrapdoor.length(), szIndexTd, SHA256_DIGEST_LENGTH);
			strIndexTrapdoor.assign(szIndexTd, SHA256_DIGEST_LENGTH);

			uint32_t uiSize = redisHelper.PoolGet(strIndexTrapdoor, strIndexVal);
			if (uiSize == 0)
			{
				//begin to return data
				break;
			}

			PRF::Sha256((char*)&uiCounter, sizeof(uiCounter), (char*)IndexMask.c_str(), IndexMask.length(), szIndexTd, SHA256_DIGEST_LENGTH);
			strIndexEqual.assign(szIndexTd, SHA256_DIGEST_LENGTH);

			if (memcmp(strIndexEqual.c_str(), strIndexVal.c_str(), SHA256_DIGEST_LENGTH) == 0)
			{
				string strDataTrapdoor(strIndexVal.c_str() + SHA256_DIGEST_LENGTH, SHA256_DIGEST_LENGTH);

				//fetch data from data-key-value-pairs
				uiSize = redisHelper.PoolGet(strDataTrapdoor, strRet);
				if (uiSize != 0) {
					_return.push_back(strRet);
				}
			}

			uiCounter++;

		}

	}

	/**
	* EqualSearch2
	* @return a binary list of Key, with fast index
	*
	* @param IndexTrapdoor
	* @param IndexMask
	*/
	void EqualSearch2(std::vector<std::string> & _return, const std::string& IndexTrapdoor, const std::string& IndexMask) {
		// Your implementation goes here


		uint32_t uiCounter = 0;

		const uint32_t kIndexValSize = SHA256_DIGEST_LENGTH + SHA256_DIGEST_LENGTH;
		char szIndexTd[kIndexValSize];

		string strIndexTrapdoor;
		string strIndexEqual;
		string strRet;

		while (true)
		{
			PRF::Sha256((char*)&uiCounter, sizeof(uiCounter), (char*)IndexTrapdoor.c_str(), IndexTrapdoor.length(), szIndexTd, SHA256_DIGEST_LENGTH);
			strIndexTrapdoor.assign(szIndexTd, SHA256_DIGEST_LENGTH);

			string strIndexVal;
			uint32_t uiSize = redisHelper.PoolGet(strIndexTrapdoor, strIndexVal);
			if (uiSize == 0)
			{
				//begin to return data
				break;
			}

			PRF::Sha256((char*)&uiCounter, sizeof(uiCounter), (char*)IndexMask.c_str(), IndexMask.length(), szIndexTd, SHA256_DIGEST_LENGTH);
			strIndexEqual.assign(szIndexTd, SHA256_DIGEST_LENGTH);

			if (memcmp(strIndexEqual.c_str(), strIndexVal.c_str(), SHA256_DIGEST_LENGTH) == 0)
			{
				string strDataTrapdoor(strIndexVal.c_str() + SHA256_DIGEST_LENGTH, SHA256_DIGEST_LENGTH);

				//fetch data from data-key-value-pairs
				uiSize = redisHelper.PoolGet(strDataTrapdoor, strRet);
				if (uiSize != 0) {
					_return.push_back(strRet);
				}
			}

			uiCounter++;

		}

	}

	/**
	* OrderSearch
	* @return a binary list of Key which meet the requirement of order
	*
	* @param IndexTrapdoor
	* @param OrderLeft
	*/
	void OrderSearch(std::vector<std::string> & _return, const std::string& IndexTrapdoor, const std::string& OrderLeft) {
		// Your implementation goes here
		uint32_t uiCounter = 0;

		const uint32_t kIndexValSize = SHA256_DIGEST_LENGTH + SHA256_DIGEST_LENGTH;
		char szIndexTd[kIndexValSize];

		string strIndexTrapdoor;

		OREHelper oreHelper;
		oreHelper.Init("A", uiBlockSizeInBits);

		while (true)
		{
			PRF::Sha256((char*)&uiCounter, sizeof(uiCounter), (char*)IndexTrapdoor.c_str(), IndexTrapdoor.length(), szIndexTd, SHA256_DIGEST_LENGTH);
			strIndexTrapdoor.assign(szIndexTd, SHA256_DIGEST_LENGTH);

			string strIndexVal;
			uint32_t uiSize = redisHelper.PoolGet(strIndexTrapdoor, strIndexVal);
			if (uiSize == 0)
			{
				//begin to return data
				break;
			}

			string strRet;

			//1 means yes
			if (1 == oreHelper.CompareORE((char*)OrderLeft.c_str(), OrderLeft.length(), (char*)(strIndexVal.c_str() + SHA256_DIGEST_LENGTH), strIndexVal.length() - SHA256_DIGEST_LENGTH, uiCounter))
			{
				string strDataTrapdoor(strIndexVal.c_str(), SHA256_DIGEST_LENGTH);

				//fetch data from data-key-value-pairs
				uiSize = redisHelper.PoolGet(strDataTrapdoor, strRet);
				if (uiSize != 0) {
					_return.push_back(strRet);
				}
			}

			uiCounter++;

		}

	}

	/**
	* Proxy RunRedis command
	* @return a binary list of the result
	*
	* @param command
	*/
	void RunCommand(std::vector<std::string> & _return, const std::vector<std::string> & command) {
		// Your implementation goes here
		redisHelper.PoolRun(command, _return);
	}

	/**
	* EqualSearch1 PlainText
	* @return a binary list of Key, with linear comparation
	*
	* @param IndexTrapdoor
	* @param IndexMask
	*/
	void EqualSearch1PlainText(std::vector<std::string> & _return, const std::string& key, const std::string& unused) {
		// Reserved for future.
		int scanCounter = 0;
		string strvalue;
		vector<string> scanParam;
		vector<string> res;
		scanParam.push_back("SCAN");
		scanParam.push_back(to_string(scanCounter));
		scanParam.push_back("COUNT");
		scanParam.push_back("10000");
		do
		{
			//At first, scan the table.
			redisHelper.PoolRun(scanParam, res);
			if (res.size() > 0)
			{
				sscanf(res[0].c_str(), "%d", &scanCounter);
				scanParam[1] = res[0];
				for (int i = 1; i < res.size(); i++)
				{
					//Then, confirm the key is EqualSearchType
					if (!isdigit(res[i].c_str()[0]))
					{
						continue;
					}
					redisHelper.PoolGet(res[i], strvalue);

					if (!key.compare(strvalue))
					{
						_return.push_back((strvalue));
					}
				}
			}
			else
			{
				scanCounter = 0;
			}
		} while (0 != scanCounter);
	}

	/**
	* EqualSearch2 PlainText
	* @return a binary list of Key, with fast index
	*
	* @param IndexTrapdoor
	* @param IndexMask
	*/
	void EqualSearch2PlainText(std::vector<std::string> & _return, const std::string& searchValue, const std::string& unused) {

		vector<string> param;
		vector<string> res;
		param.push_back("ZRANGEBYSCORE");
		param.push_back("index");
		param.push_back(searchValue);
		param.push_back(searchValue);
		//Get the Key in the SortedSet
		redisHelper.PoolRun(param, res);
		string value;


		for (vector<string>::iterator i = res.begin(); i != res.end(); i++)
		{
			redisHelper.PoolGet(*i, value);
			//If it is right for search, add it.
			if (searchValue.compare(value) == 0)
			{
				_return.push_back(searchValue);
			}
		}

	}

	/**
	* OrderSearch PlainText
	* @return a binary list of Key which meet the requirement of order
	*
	* @param IndexTrapdoor
	* @param OrderLeft
	*/
	void OrderSearchPlainText(std::vector<std::string> & _return, const std::string& key, const std::string& cmp) {
		int scanCounter = 0;
		int ikey = stoi(key);
		bool bcmp = cmp.compare("1") ? false : true;
		int val;
		string strvalue;
		vector<string> scanParam;
		vector<string> res;
		//use "KEYS" command to scan all data at once
		scanParam.push_back("KEYS");
		scanParam.push_back("*");
		//At first, get all keys of the table.
		redisHelper.PoolRun(scanParam, res);
		if (res.size() > 0)
		{
			for (int i = 0; i < res.size(); i++)
			{
				//Then, confirm the key is OrderSearchType
				bool isAdigit = true;
				for (int j = 0; j < res[i].size(); j++)
				{
					if (!isdigit(res[i].at(j)))
					{
						isAdigit = false;
						break;
					}
				}
				if (!isAdigit)
				{
					continue;
				}

				redisHelper.PoolGet(res[i], strvalue);
				sscanf(strvalue.c_str(), "%d", &val);

				if ((bcmp && val > ikey) || (!bcmp && val < ikey))
				{
					//If it is right for cmp, return it.
					_return.push_back(to_string(val));
				}
			}
		}
	}
};

int main(int argc, char **argv) {

	int port = 9090;

	if (argc != 2)
	{
		cout << "usage : ./" << argv[0] << " [BlockSizeInBit]" << endl;
		cout << "The Block_size in bit is [BlockSizeInBit]." << endl;
		return;
	}

	uint32_t uiBlockSizeInBits;
	sscanf(argv[1], "%u", &uiBlockSizeInBits);

	boost::shared_ptr<TProxyServiceHandler> handler(new TProxyServiceHandler());

	handler->uiBlockSizeInBits = uiBlockSizeInBits;

	boost::shared_ptr<TProcessor> processor(new TProxyServiceProcessor(handler));
	boost::shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
	boost::shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
	boost::shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());


	//#define DEF_USE_THREADPOOL

#ifdef DEF_USE_THREADPOOL

	const int workerCount = 500;

	boost::shared_ptr<ThreadManager> threadManager = ThreadManager::newSimpleThreadManager(workerCount);
	boost::shared_ptr<PosixThreadFactory> threadFactory = boost::shared_ptr<PosixThreadFactory>(new PosixThreadFactory());
	threadManager->threadFactory(threadFactory);

	threadManager->start();

	TThreadPoolServer server(processor, serverTransport, transportFactory, protocolFactory, threadManager);

#else



  //TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
	TThreadedServer server(processor, serverTransport, transportFactory, protocolFactory);


#endif

	server.serve();


	return 0;
}

